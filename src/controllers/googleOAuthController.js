const { OAuth2Client } = require('google-auth-library');\nconst { google } = require('googleapis');\nconst User = require('../models/User');\nconst GoogleToken = require('../models/GoogleToken');\nconst jwt = require("jsonwebtoken");\nconst { notifyAdmins } = require("../services/emailService");\n\nconst SCOPES = [\n    'https://www.googleapis.com/auth/userinfo.email',\n    'https://www.googleapis.com/auth/userinfo.profile',\n    'https://www.googleapis.com/auth/drive.file', // Acesso a arquivos criados pelo app\n    'https://www.googleapis.com/auth/spreadsheets', // Acesso a Google Sheets\n    'https://www.googleapis.com/auth/calendar' // Acesso a Google Calendar\n];\n\nconst redirectUri = process.env.GOOGLE_CALLBACK_URL\n    || (process.env.BASE_URL ? `${process.env.BASE_URL}/api/auth/google/callback` : 'http://localhost:3000/api/auth/google/callback');\n\nconst oauth2Client = new google.auth.OAuth2(\n    process.env.GOOGLE_CLIENT_ID,\n    process.env.GOOGLE_CLIENT_SECRET,\n    redirectUri\n);\n\n// ---------------------\n// 1. Inicia o fluxo OAuth\n// ---------------------\nexports.authStart = (req, res) => {\n    const authUrl = oauth2Client.generateAuthUrl({\n        access_type: process.env.GOOGLE_ACCESS_TYPE || 'offline',\n        prompt: process.env.GOOGLE_PROMPT || 'consent',\n        scope: SCOPES,\n        state: req.query.state || 'default' // Pode ser usado para passar informações de estado\n    });\n    res.redirect(authUrl);\n};\n\n// ---------------------\n// 2. Callback do Google\n// ---------------------\nexports.authCallback = async (req, res) => {\n    try {\n        const { code } = req.query;\n        \n        // 1. Troca o código por tokens\n        const { tokens } = await oauth2Client.getToken(code);\n        oauth2Client.setCredentials(tokens);\n\n        // 2. Obtém informações do usuário\n        const oauth2 = google.oauth2({\n            auth: oauth2Client,\n            version: 'v2',\n        });\n        const userInfo = await oauth2.userinfo.get();\n        const emailGoogle = userInfo.data.email;\n\n        // 3. Busca ou cria o usuário no banco de dados local\n        let user = await User.findOne({ where: { email: emailGoogle } });\n\n        if (!user) {\n            // Cria novo usuário (pendente de aprovação)\n            user = await User.create({\n                nome_completo: userInfo.data.name || "Usuário Google",\n                cargo_id: 2, // Cargo padrão\n                cpf: "00000000000", // CPF placeholder\n                email: emailGoogle,\n                contato: "N/A",\n                senha_hash: "",\n                situacao: "pendente"\n            });\n            await notifyAdmins(user);\n            return res.status(403).send("Usuário criado. Aguardando aprovação de administrador. Pode fechar esta aba.");\n        }\n\n        if (user.situacao !== "ativo") {\n            return res.status(403).send("Usuário não aprovado. Pode fechar esta aba.");\n        }\n\n        // 4. Salva ou atualiza os tokens do Google\n        const [googleToken, created] = await GoogleToken.findOrCreate({\n            where: { user_id: user.id_usuario },\n            defaults: {\n                user_id: user.id_usuario,\n                access_token: tokens.access_token,\n                refresh_token: tokens.refresh_token,\n                scope: tokens.scope,\n                token_type: tokens.token_type,\n                expiry_date: tokens.expiry_date,\n            }\n        });\n\n        if (!created) {\n            googleToken.access_token = tokens.access_token;\n            googleToken.refresh_token = tokens.refresh_token || googleToken.refresh_token; // Mantém o refresh token se não for fornecido\n            googleToken.scope = tokens.scope;\n            googleToken.token_type = tokens.token_type;\n            googleToken.expiry_date = tokens.expiry_date;\n            await googleToken.save();\n        }\n\n        // 5. Gera JWT para o login na aplicação\n        const appToken = jwt.sign(\n            { id: user.id_usuario, email: user.email, cargo_id: user.cargo_id },\n            process.env.JWT_SECRET,\n            { expiresIn: process.env.JWT_EXPIRES_IN || "1h" }\n        );\n\n        // 6. Redireciona para o frontend com o token (ou exibe mensagem de sucesso)\n        // Idealmente, redirecionaria para o frontend com o appToken na URL ou cookie.\n        // Por enquanto, apenas exibe o token e uma mensagem de sucesso.\n        \n        // 6. Redireciona para o frontend com o token JWT da aplicação.\n        // O frontend irá capturar esse token pela query string e salvar localmente.\n        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';\n        const normalizedFrontendUrl = frontendUrl.replace(/\/$/, '');\n        const redirectUrl = `${normalizedFrontendUrl}/google-auth/callback?token=${encodeURIComponent(appToken)}`;\n        return res.redirect(302, redirectUrl);\n\n\n    } catch (error) {\n        console.error('Erro no callback do Google:', error);\n        res.status(500).send(`\n            <html>\n                <head>\n                    <title>Erro no Login Google</title>\n                </head>\n                <body>\n                    <h1>❌ Erro no Login Google</h1>\n                    <p>Ocorreu um erro durante o processo de autenticação.</p>\n                    <p>Detalhes: ${error.message}</p>\n                    <p>Se o erro for 'redirect_uri_mismatch', verifique se a URL <code>${process.env.BASE_URL}/api/auth/google/callback</code> está configurada no Google Cloud Console.</p>\n                </body>\n            </html>\n        `);\n    }\n};